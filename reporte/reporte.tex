\documentclass{article}

% Márgenes.
\usepackage{geometry}
\addtolength{\hoffset}{-0.2cm}
\addtolength{\textwidth}{0.4cm}
\addtolength{\voffset}{-0.5cm}
\addtolength{\textheight}{1cm}

% Caracteres especiales del español.
\usepackage[utf8]{inputenc}

% Para el lenguaje español.
\usepackage[spanish]{babel}

% Símbolos matemáticos
\usepackage{amssymb}

% Algoritmos
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

% Macros.
\newcommand{\tbf}[1]{\textbf{#1}}

\newcommand{\tit}[1]{\textit{#1}}

\newcommand{\ttt}[1]{\texttt{#1}}

% Título y autor del reporte.
\title{Uso de la Heurística de Recocido Simulado para Resolver
       el Problema del Agente Viajero (TSP)}
\author{Carrasco-Ruiz Mauricio  \\
	maucarrui@ciencias.unam.mx  \\
        Universidad Nacional Autónoma de México (UNAM) \\
        Facultad de Ciencias \\
        Heurísiticas de Optimización Combinatoria \\
	}

% Fecha de hoy.
\date{\today} 

\begin{document}

  \maketitle


  \begin{abstract}
    El Problema del Agente Viajero (TSP) es uno de los problemas 
    más famosos de optimización combinatoria que pertenecen a la 
    clase \tbf{NP-duro}. Los algoritmos que son capaces de resolver
    este problema toman tiempo factorial o exponencial en producir algún 
    resultado, por lo que para ello se optó por utilizar una heurística
    para encontrar soluciones factibles a este problema; mejorando el
    tiempo en el que se producen resultados. En este trabajo se utilizó 
    la heurística de Aceptación por Umbrales implementada en el lenguaje de
    programación \tbf{C++}. Se tomaron dos conjuntos de prueba para 
    el problema: un conjunto de 40 ciudades y otro conjunto de 150 
    ciudades. Los mejores resultados obtenidos a partir de 500 semillas 
    de prueba fueron soluciones factibles con un costo que se podría 
    considerar cercano al óptimo. Concluyendo de esta forma 
    que la heurísitica de recocido simulado es una buena alternativa 
    para resolver el problema del agente viajero.
  \end{abstract}

  \section{Introducción} \label{intro}
  Dentro de la teoría de la computación existen clases en donde 
  se encuentran contenidos problemas que cumplen cierta propiedad. Por ejemplo,
  existe la clase \tbf{P} en donde se encuentran todos los problemas que 
  pueden ser decididos por una Máquina de Turing en tiempo polinomial;
  también existe la clase \tbf{NP} en donde se encuentran todos los 
  problemas para los cuales existe una Máquina de Turing No Determinista que
  los decide en tiempo polinomial. En este trabajo nos vamos a enfocar
  en la clase \tbf{NP-duro}, en la cual se encuentran todos los 
  problemas $H$ tales que todos los problemas $L$ de la clase \tbf{NP} se 
  pueden reducir en tiempo polinomial a $H$; en otras palabras, los problemas
  en \tbf{NP-duro} son al menos tan difíciles como los problemas más difíciles 
  de \tbf{NP}.

  \subsection{El Problema del Agente Viajero (\tit{Travelling Salesman Problem})}
  \label{TSP}
  El Problema del Agente Viajero (\tit{TSP}), es uno de los problemas más 
  famosos que se encuentra en la clase \tbf{NP-duro}. Propuesto por el 
  matemático Irlandés W.R. Hamilton y el matemático Inglés Thomas Kirkman 
  en el siglo XIX, el problema es formulado de la siguiente manera:

  \begin{quote}
    \tit{``Dado un conjunto de ciudades en un mapa, ¿cuál es el camino 
      más corto que pasa por todas ellas?''}
  \end{quote}

  Para ello el problema es representado mediante una gráfica $G = (V, E)$, 
  en donde  el conjunto de vertices $V$ representa a las ciudades del mapa, 
  y el conjunto de aristas $E \subseteq V \times V$ nos indica si existe 
  o no un camino entre dos ciudades. Cabe mencionar que nuestras aristas 
  van a tener pesos, es decir, tenemos una función 
  $w: E \rightarrow \mathbb{R}^+$; de esta manera, podremos representar 
  de una mejor manera la distancia o el costo que hay de ir de una ciudad 
  a otra. Y también vamos a suponer que la gráfica es completa, de 
  esta forma siempre va a existir una arista entre cualquiera par de 
  ciudades.

  Dicho todo lo anterior, el objetivo del TSP es encontrar un ciclo 
  hamiltoniano dentro de la gráfica; es decir, un ciclo que pase por 
  todos los vértices de la gráfica sin repetir aristas o vértices 
  (más que el inicial y el final). Sin embargo, para este trabajo se 
  hará una pequeña modificación al TSP y en vez de buscar un ciclo 
  hamiltoniano, lo que se buscará es una trayectoria hamiltoniana; una 
  trayectoria que pase por todos los vértices de la gráfica.

  Si nosotros quisieramos encontrar esta trayectoria con un algoritmo,
  entonces la manera más sencilla sería calcular todas las 
  posibles trayectorias y regresar la que menos costo tenga y 
  recorra a todos los vértices; sin embargo calcular todas las posibles 
  trayectorias toma tiempo factorial, por lo que para conjuntos pequeños 
  como con 40 o 150 ciudades, esto ya empieza a tomar una cantidad 
  excesiva de tiempo. Entonces no es viable tener un algoritmo así para 
  poder obtener la trayectoria que estamos buscando, para ello vamos 
  a buscar una alternativa.

  \subsection{Heurísticas} \label{heuristic}
  Una heurística, informalmente, es una metodología que se sigue con 
  la finalidad de conseguir una solución al problema en un tiempo 
  relativamente rápido y lo \tit{suficientemente} buena, pero 
  no necesariamente óptima o perfecta, en comparación a otras 
  soluciones.

  Por lo que para el TSP se decidió usar una heurística para poder 
  obtener una solución factible debido a la velocidad y calidad que
  ofrecen en sus resultados.

  \subsubsection{Aceptación por Umbrales} \label{simulatedAnnealing}
  Una heurística bastante conocida es la del \tbf{Recocido Simulado}. 
  Propuesta en 1983 por Scott Kirkpatrick, Daniel Gelatt y Mario
  Vecchi, su objetivo era simular la técnica de \tit{recocido}
  utilizada en la metalurgía para deformar y fortalecer metales sin 
  tener defectos en ellos. Esto lo consiguen calentando primero el 
  metal a grandes temperaturas, después se enfría el metal y por 
  último se moldea un poco; repetir este proceso asegura que el 
  metal no perderá su dureza y tendrá la forma que se desea.

  Podemos simular esta técnica dentro de la computación, en donde 
  tendríamos una solución inicial que sería nuestro equivalente 
  del metal en un forma original, y el objetivo sería ir calentando 
  nuestra solución e irla moldeando para que poco a poco vaya tomando 
  la forma de una solución óptima, concluyendo al final con una 
  solución \tit{suficientemente} buena.

  Sin embargo, la heurística que vamos a utilizar es un derivado 
  de la del recocido simulado. La heurística de \tbf{Aceptación por 
  Umbrales}, propuesta por Gunter Dueck y Tobias Scheuer en 1990,
  consiste en tener una temperatura inicial $T$, una solución 
  inicial $s$, una manera de generar otras soluciones $s'$ a partir
  de una solución $s$, un factor de enfriamiento $\phi$, y una función 
  de costo $f$ para evaluar a las soluciones.
  
  La idea principal de esta heurística será generar vecinos $s'$ de la 
  solución actual $s$ (en un principio la inicial) y evaluar si se 
  cumple que  $f(s') < f(s) + T$, si es así entonces ahora nuestra 
  solución actual será $s'$ y se dirá entonces la solución $s'$ 
  fue aceptada; de ahí su nombre. Continuamos, multiplicando 
  a $phi$ por $T$ (bajamos la temperatura por el factor de enfriamento).
  Y repetimos este proceso hasta que $T < \epsilon$ o se tenga un 
  límite de soluciones aceptadas.

  Las soluciones de la heurística serán las trayectorias hamiltonianas
  de la gráfica, la función de costo será solo sumar el peso de todas 
  las aristas de esta trayectoria, y para generar el vecino de una 
  solución lo que vamos a hacer es intercambiar de lugar dos ciudades
  en la trayectoria. De esta forma ya tenemos adaptada nuestra 
  huerística para que pueda empezar a resolver el Problema del Agente 
  Viajero.

  \section{Desarrollo} \label{development}
  Debido a que uno de los principales factores que se buscaron en el
  programa fue la velocidad en la que producen resultados, el 
  lenguaje de programación por el que se optó fue \tbf{C++} gracias a
  la rapidez en la que se ejecutan los programas a comparación de otros 
  lenguajes compilados o interpretados (Python, Vala, entre otros).

  Cabe mencionar que se va a trabajar con una base de datos en donde 
  se encuentra la información de 1092 ciudades y sus conexiones entre 
  ellas.

  \subsection{Diseño del proyecto}
  Aprovechando que \tbf{C++} sigue el paradigma de \tbf{Orientación a 
  Objetos}, se decidió estructurar al programa en diversas clases con 
  la finalidad de modularizar lo más posible el TSP. Por esa razón,
  terminamos con las sigientes clases:
  
  \begin{itemize}
    \item Ciudad

      El objeto ciudad, como su nombre lo indica, representa a una ciudad
      en el TSP. Sus atributos consisten en la información que nosotros 
      podemos obtener de las ciudades en la base de datos, las cuales son:
      un identificador (ID), su nombre, el país en el que se encuentra, 
      la población que tiene, su latitud y su longitud. Este objeto 
      como tal no tiene métodos que nos sean de interés, pero hay que 
      mencionar que por diseño se decidió colocar \tit{getters} para 
      poder obtener, sin acceder a atributos privados, la información 
      deseada.

    \item DAO (\tit{Data Access Object})
      
      El \tit{Data Access Object} es aquel con el cual podimos establecer 
      una conexión con la base de datos y así conseguir la información de 
      las ciudades y sus conexiones. Su atributo consiste únicamente en el 
      apuntador en donde se encuentra alojada nuestra base de datos en la
      máquina, y sus métodos consisten en obtener una ciudad dado su 
      identificador y obtener una conexión entre ciudades dados los dos 
      identificadores de las ciudades.
      
    \item Gráfica
      
      Hay muchas maneras de representar a una gráfica dentro de un programa
      de cómputo. Sin embargo, como constantemente se va a estar buscando 
      el peso de las adyacencias entre dos ciudades para calcular el costo 
      de una solución, es necesario que tengamos este valor en la menor 
      cantidad de tiempo para que nuestro programa no sea tan lento 
      al momento de calcular distancias. Por esa razón, las gráficas 
      son representadas mediante su matriz de adyacencias.

      También para poder optimizar nuestra matriz y que ocupe la menor 
      cantidad de espacio posible, lo que se decidió es sólo construir la 
      matriz de la subgráfica generadora que contiene sólo a las ciudades 
      con las que se va a trabajar para el TSP; pues en el caso de 
      tener 40 ciudades, nuestra matriz sería de tamaño $40^2 = 1600$,
      en comparación de construir la matriz de adyacenciencia para la 
      gráfica completa que sería de tamaño $1092^2 = 1192464$.

      Un detalle importante sobre nuestra implementación es que no para 
      cualquier par de ciudades va a existir una conexión entre ellas, por
      lo que para solucionar este problema lo que hacemos es asignarles
      una arista con un peso muy grande; el peso es calculado de la 
      siguiente manera:

      \[ w(u, v) = d(u, v) \cdot max_d(S) \]
      
      En donde $S$ es el conjunto de ciudades para las cuales vamos 
      a trabajar el TSP, $u, v \in V$, $d(u, v)$ se refiere a la 
      distancia natural que existe entre $u$ y $v$, y $max_d(S)$ es 
      el peso más grande de la subgráfica generada por $S$. De esta forma,
      si $u$ y $v$ no se encontraban originalmente conectadas en 
      $G$, ahora lo van a estar con una arista cuyo peso será lo 
      suficientemente grande para que nuestra heurística no la coloque 
      en nuestra solución.
      
    \item Solución
      
      Como su nombre lo indica, representa una solución dentro de nuestro 
      programa. Nosotros entendemos como una solución a una secuencia de 
      números donde cada número es el identificador de una ciudad, es decir
      una trayectoria dentro de nuestra subgráfica. Como la gráfica es 
      completa desde un principio, entonces cualquier secuencia de números 
      (con la única excepción de que no se tengan repetidos) va a ser una 
      solución válida. Sin embargo, no toda solución que nuestro programa
      produzca va a ser una \tit{buena} solución, pues la trayectoria puede 
      que contenga alguna o varias aristas con un peso gigantesco; a 
      aquellas soluciones que cuyas aristas sí estaban originalmente en la 
      gráfica les llamaremos \tbf{factibles}. Entonces para diferenciar 
      soluciones y poder determinar cuáles son factibles y cuáles no, 
      vamos a tener la siguiente función de costo:

      \[ f(T) = \frac{\sum_{i=2}^k w(v_{i-1}, v_i)}{N(S)} \]

      Donde $T = (v_0, \cdots, v_k)$ es la trayectoria que representa
      nuestra solución, y $N(S)$ es el normalizador del conjunto $S$.
      Nosotros definimos al normalizador como:
      
      \[ N(S) = \sum_{d \in L'} d \]
      
      En donde $L'$ es la lista que contiene a las $|S|-1$ aristas 
      más pesadas de la subgráfica generadora (después de haber 
      agregado las aristas faltantes para completar la gráfica).

      De esta forma, las soluciones factibles se van a evaluar entre 
      0 y 1, y las soluciones no factibles se van a evualar a algo 
      mayor que 1.

      Ahora, para generar el vecino de una solución, como 
      se mencionó en la sección \ref{intro}, consiste en intercambiar
      a dos ciudades de la secuencia de orden. De esta manera obtenemos
      una nueva trayectoria hamiltoniana que puede que ahora use o no 
      una de las aristas que estaban originalmente en la subgráfica 
      generadora. Por lo tanto para este método lo único que 
      se necesitó fueron dos números aleatorios que se encuentren 
      dentro del rango de los índices de la trayectoria, los 
      intercambiamos y listo.

    \item Huerística

      Lo más importante de nuestro proyecto, la heurística. Como se 
      mencionó en la sección \ref{intro}, la aceptación por umbrales consiste 
      en tener una gráfica, una temperatura, una cantidad de soluciones 
      por lote, un factor de enfriamiento y epsilons. Todo lo anterior,
      son los atributos que va a contener nuestra clase Heurística.
      
      Después de eso, se tienen dos métodos que describen el 
      funcionamiento de la heurística. Primero tenemos el método
      \tbf{Calcula lote} que se encarga de producir un lote de soluciones
      y quedarnos con la mejor aptitud tuvo durante todo el proceso;
      manteniendo a la vez, la mejor solución que se ha encontrado hasta 
      ese momento. Lo que regresa el método anterior es el promedio de 
      soluciones que se aceptaron y la mejor solución del lote. Y después
      tenemos el método de \tbf{aceptación por umbrales}, el cual se encarga
      de disminuir la temperatura hasta que sea menor a una $\epsilon$,
      mientras que a la vez, usando el método anterior, calcula un lote 
      soluciones hasta que se llegue a un equilibrio térmico (lo cual se 
      puede entender como que el promedio de la cantidad de soluciones 
      aceptadas dada una temperatura y la solución actual sea mayor a la 
      de la solución anterior.

      \begin{algorithm}[H]
        \caption{Calcula lote}
        \SetAlgoLined
        $c \leftarrow 0$\;
        $r \leftarrow 0.0$\;
        \While{$c < L$} {
          $s' \leftarrow vecino(s)$\;
          \If{$f(s') < f(s) + T$} {
            $s \leftarrow s'$\;
            $c \leftarrow c + 1$\;
            $r \leftarrow r + f(s')$\;
          }
        }
        \Return $\frac{r}{L}, s$\;
      \end{algorithm}

      \begin{algorithm}[H]
        \caption{Aceptación por Umbrales}
        \SetAlgoLined
        $p \leftarrow 0$\;
        \While{$T>\epsilon$}{
          $q \leftarrow \infty$\;
          \While{$p \leq p$}{
            $q \leftarrow p$\;
            $p,s \leftarrow CalculaLote(T,s)$\;
          }
          $T \leftarrow \phi T$\;
        }
      \end{algorithm}
  \end{itemize}
  
  \subsection{Optimizaciones sobre el proyecto}

  El proyecto ofrece en distintos puntos varias optimizaciones
  sobre el espacio y tiempo. En un total de 3 optimizaciones, 
  dos afectan el tiempo reduciéndolo de lineal a constante 
  y una afecta espacio reduciendolo de lineal a constante. 
  Mejorando notablemente el rendimiento de nuestro 
  proyecto.
  
  \subsubsection{Tabla de índices para la matriz de adyacencia}
  Como mencionamos, nuestra gráfica sólo va a contener a las 
  ciudades (vértices) sobre los cuales vamos a trabajar para el 
  TSP. Por ende, buscar el renglón o columna en el que se 
  encuentra una ciudad con ID $k$ no necesariamente va a corresponder
  al $k$-ésimo renglón y columna. Para resolver esto, y a la vez 
  preservar la ventaja de que la matriz nos da tiempo de acceso 
  constante a sus elementos, se decidió utilizar una tabla 
  hash (\tit{hash table}) en donde la llave sería el identificador 
  de la ciudad y su valor el índice de la matriz que le corresponde 
  a la ciudad. De esta forma, dada la tabla hash $h$ y el 
  idenficador $k$ de la ciudad, encontrar el índice de la ciudad 
  en la matriz es sólo hacer la operación $h(k)$.

  El acceso a elementos de una hash table dada la llave en C++
  toma tiempo constante, y una vez obtenido el valor de la 
  llave, buscar ese elemento en nuestra matriz de adyacencias 
  toma igual tiempo constante. Por lo que la optimización preserva
  que el tiempo de acceso para ver el peso entre la conexión de 
  dos ciudades sea de $O(1)$; con el pequeño costo de que ademas 
  de tener nuestra matriz de tamaño $O(|S|^2)$, ahora 
  tenemos una tabla de tamaño $O(|S|)$.
  
  \subsubsection{Costo del vecino de una solución}
  Calcular el costo de una trayectoria toma tiempo lineal, pues 
  necesariamente hay que sumar el peso de todas las aristas que 
  se encuentran en nuestra trayectoria. Sin embargo, al momento 
  de obtener un vecino, podemos calcular el costo de este 
  vecino en tiempo constante.

  Sea $T = (v_0, ..., v_i, ..., v_j, ..., v_k$) nuestra 
  solución, podemos generar un vecino intercambiando de posición
  a $v_i$ con $v_j$. Si nosotros lo vemos como una trayectoria,
  lo anterior sería lo equivalente a borrar 4 aristas y 
  agregar 4 nuevas aristas. Las aristas que se ven modificadas
  son las siguientes:
  
  \begin{itemize}
    \item Eliminadas
      \begin{itemize}
        \item $v_{i-1}v_i = e_1$
        \item $v_iv_{i+1} = e_2$
        \item $v_{j-1}v_j = e_3$
        \item $v_jv_{j+1} = e_4$
      \end{itemize}
    \item Agregadas
      \begin{itemize}
        \item $v_{i-1}v_j = e_1'$
        \item $v_jv_{i+1} = e_2'$
        \item $v_{j-1}v_i = e_3'$
        \item $v_iv_{j+1} = e_4'$
      \end{itemize}
  \end{itemize}

  Por lo que si teníamos una solución $s$ y su costo $f(s)$, 
  si generamos un nuevo vecino $s'$, calcular su costo solo 
  sería hacer la siguiente operación:

  \[ f(s') = f(s) + 
             \frac{(w(e_1)' + w(e_2)' + w(e_3)' + w(e_4')) -
                   (w(e_1) + w(e_2) + w(e_3) +w(e_4))}{N(S)} \]

  Es decir, restamos el costo de las aristas que eliminamos y 
  sumamos el costo de las que agregamos, lo dividimos todo 
  sobre el normalizador y lo sumamos con el costo que 
  teníamos de $s$. De esta forma, una operación que 
  antes nos hubiera tomado tiempo lineal en calcular, ahora 
  nos toma tiempo constante. Y más importante aún, solo tenemos 
  calcular una sola vez en tiempo lineal el costo de una solución 
  durante todo el proyecto, el de la solución inicial; calcular el 
  costo de las siguientes soluciones que se vayan a generar en 
  la heurísitica tomará tiempo constante pues son vecinas de la 
  solución inicial, o vecinas de la vecina y así consecutivamente.

  \subsubsection{Sólo 3 objetos Soluciones en toda la ejecución}
  Una manera sencilla de programar este proyecto es que cada 
  que se genere una nueva solución se cree un nuevo objeto 
  solución. El problema radica en que si el programa se ejecuta 
  la suficiente cantidad de tiempo, la memoria que se va a 
  ocupar va a ser bastante pues no hay un recolector de basura 
  para C++, y liberar la memoria manualmente puede ser un reto 
  un tanto peligroso si no se sabe lo que se hace.

  Para resolver el problema, se decidió tener un total de 
  3 objetos soluciones, los cuales por medio de métodos
  \tit{setters} y \tit{getters} pueden cambiar sus atributos 
  sin la necesidad de tener que crear nuevos objetos
  que tengan estos nuevos valores. Mejorando de esta manera
  la cantidad de espacio que consume nuestro programa, terminando 
  con un número constante de objetos que existen durante la 
  ejecución.

  \section{Experimentación y Resultados} \label{results}
  \ldots

  \section{Discusión} \label{discussion}
  \ldots

  \section{Conclusión} \label{conclusion}
  \ldots

  \begin{thebibliography}{9}

    \bibitem[X]{X} \ldots

  \end{thebibliography}

\end{document}
